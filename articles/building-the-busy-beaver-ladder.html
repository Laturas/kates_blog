<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Building the Busy Beaver Ladder</title>
	<link rel="stylesheet" href="../css/main.css">
	<link rel="stylesheet" href="../css/katex.min.css">
	<script defer src="../js/katex.min.js"></script>
	<!-- Automatically renders math in text elements -->
	<script defer src="../js/auto-render.min.js"onload="renderMathInElement(document.body);"></script>
	<link rel="icon" type="image/png" href="../media/favicon.png"> 
</head>
<body>
	<header class="banner">
		<h1>Katelyn's Blog</h1>
	</header>
	<div class="main-block">
		<nav class="navigation">
			<ul>
				<li>
					<a href="../index.html">Home</a>
				</li>
				<li>
					<a href="../articles.html">Articles</a>
				</li>
				<li>
					<a href="../projects.html">Projects</a>
				</li>
			</ul>
		</nav>
		<article id="article_body">
			<header class="article-header">
				<h1 class="article-title">
					Building the Busy Beaver Ladder
				</h1>
				<p class="article-date">
					September 23 2025
				</p>
			</header>
			<hr>
			<main>
				<p>
					Gaze not into the abyss of arithmetical statements, or it will gaze back.
				</p>
                <p>
                    Turing Machines are fascinating little devices for encoding mathematical problems. It asks the question of if a turing machine with a set of instructions ever reaches a specific instruction (the halt state).

                    The way this is worded will be important later. 
                </p>
                <p>
                    It turns out you can encode any "there exists" problem into the halting problem of a turing machine! But of course, that's not all the problems that exist. For example, you cannot encode the twin prime conjecture (directly at least, to my knowledge) into a turing machine.
                    That's a "for all x, there exists a y" problem which is too much for our machines to handle.
                </p>
                <p>
                    That's where Scott Aaronson's Beeping Turing Machines come in. We can move one level up and ask if a specific state is reached infinitely often. Or, for all times that state is reached, there exists a following step for which that state is reached again. The machine "quasihalts" if the state is only reached finitely many times.
                </p>
                <p>
                    You can encode a lot more problems using this construction, but eventually you again run into a wall. How would you encode the problem, "for all collatz maps defined by k (map an integer n to \((2k + 1)n + 1\) if n is odd, \(\frac{n}{2}\) if it's even), there exists an integer such that repeatedly applying this rule goes to infinity"?
                </p>
				<p>
					A new construction was created by Bram Cohen, named the Beeping Booping Turing Machine. Every time you reach a boop state, count how many times a beep state was reached previously and output that number. The machine "pseudoquasihalts" if there exists a number that is output infinitely often.
				</p>
				<p>
					And that's where the ladder was stuck. While you can encode probably most interesting problems with only those 2 extra rungs, you can't encode <strong>every</strong> problem. One may ask, is there a way to generalize these two constructions?
				</p>
				<p>
					That's what I hope to answer today.
				</p>
				<h2>
					The Problem of Oracles
				</h2>
				<hr>
				<p>
					Each of the previous two rungs are equivalent to equipping a turing machine with an oracle that can solve the halting problem of the rung below. To solve a machine's beeping halting problem, you need to solve its regular halting problem. And similar for the beeping booping halting problem and the beeping halting problem.
				</p>
				<p>
					While the notion of generalized oracle turing machines is well established, the constructions of them leave a lot to be desired. There are a lot of strange, unnatural (in my opinion) choices you have to make in regards to how a turing machine communicates with its oracle, and the exact nature of the oracle itself.
					This is really unfortunate too, when considering other models of computation can have very straightforward and intuitive ways to extend them.
				</p>
				<p>
					The reason the beeping, and beeping booping extensions are nice is that they have a few key properties. For one, each builds off the last, introducing only a single new "sound" per halting problem level and a rule for interpreting said sound.
				</p>
				<p>
					For another, and in my opinion the most important part, it does not actually change the execution of the base turing machine. The transition table is enough to describe the behavior of a turing machine on the tape for all time (I.E. If you look at the tape of a turing machine at step n, it will always look the same no matter what sounds are attached). It only changes the question you're asking about it.
				</p>
				<p>
					A generalized method of constructing halting problems of arbitrary difficulty should retain these two properties.
				</p>
				<h2>
					The Order N Halting Problem
				</h2>
				<hr>
				<p>
					Let an order-n "sound" correspond to a unique output upon reaching a specific instruction (or set of instructions).
				</p>
				<p>
					Let two order-(n+1) sounds be "equivalent" if for each sound, between it and the previous order-(n+1) sound (or the start of execution), there is the same number of abundant order-n sounds.
				</p>
				<p>
					Let an order-n sound be "abundant" if it is equivalent to infinitely many other order-n sounds that eventually occur.
				</p>
				<p>
					Let all order-1 sounds (beeps) be equivalent.
				</p>
				<sub-block>
					<p>
						<strong>Definition 1:</strong> Order-n Halting Problem
					</p>
					<p>
						If n = 2k, a machine order-n halts on the first step that an abundant order-k sound occurs.
					</p>
					<p>
						If n = 2k+1, a machine order-n halts on the first step that all abundant order-k sounds have occurred at least once.
					</p>
				</sub-block>
				<p>
					And for those of you that want a more rigorous, mathematically precise definition:
				</p>
				<sub-block>
					<p>
						<strong>Definition 1:</strong> Order-n Halting Problem (rigorous)
					</p>
					<p>
						Let \(i \equiv_n j \leftrightarrow S_n(i) = S_n(j)\)
						<br>
						Let \(S_{n+1}(m) =\) the amount of i such that the \(i\)-th order-n sound is between the \(m\)-th pair of consecutive order-(n+1) sounds and i is in an infinite n-equivalence class (i.e. \(S_n(i) = S_n(j)\) for infinitely many \(j\))
						<br><br>
						order-(2n) halt on the \(i\)-th order-n sound, where i is the minimum of the union of infinite n-equivalence classes (i.e. \(i\) is minimal such that \(S_n(i) = S_n(j)\) for infinitely many \(j\))
						<br><br>
						order-(2n+1) halt on the \((i+1)\)-th order-n sound, where i is the maximum of the set of minima of infinite n-equivalence classes. (i.e. \(i\) is maximal such that \(S_n(i) = S_n(j)\) for infinitely many \(j\) and \(i\) is minimal for all such \(j\))
					</p>
				</sub-block>
				<p>
					And now, I offer a proof that any statement on the arithmetical hierarchy can be encoded as a sufficiently strong halting problem with the above construction.
				</p>
				<p>
					<strong>Theorem:</strong> Any \(\Sigma_{n + 1}\) statement can be encoded into the halting problem of an order-n turing machine.
				</p>
				<button id="btn_turing_jmp_proof" class="proof-button"></button>
				<sub-block id="turing_jmp_proof">
					<p><strong>Case 1:</strong> \(n = 2k\)</p>
					<p>
						Let a \(\Sigma_{n+1}\) statement exist of the form \((\exists a \forall b \exists c... \forall n \exists o) P(a, b, c, d, ...)\)
						Let each variable be a unique natural number mapped to that number. Now, define a machine that enumerates every statement of that form (which is possible because any set of n-tuples is countable).
					</p>
					<p>
						Now we need to assign sounds. For each existential variable, assign a sound in decreasing order. Every time a statement is satisfied, start at the last existential variable (call it \(e\)) and work upward.
						Existential variable \(e\) will have an an order-i sound associated with it. Make the order-(i) sound \(e\) times and then move up to the next existential variable, and repeat. However, only make the highest order sound once.
					</p>
					<p>
						Define the machine to order-n halt in accordance with the "even case" definition.
					</p>
					<p>
						If the statement is true, then there exists a set of existential variables that will allow the statement to always be satisfied regardless of the forall statements. This means there exists an order-(k+1) sound with an order-(k) subsequence that will always be played.
						If the statement is false, then any set of existential variables can only be satisfied a finite number of times and thus any sequence of order-k sound will only play finitely many times. This indicates the machine will never order-n halt.
					</p>
					<p>
						Therefore this machine's order-n halting problem is equivalent to the \(\Sigma_{n+1}\) statement.
					</p>
					<p><strong>Case 2:</strong> \(n = 2k + 1\)</p>
					<p>
						Let a \(\Pi_{n+1}\) statement exist of the form \((\forall a \exists b \forall c \exists d... \forall n \exists o) P(a, b, c, d, ...)\).
						Similarly to the previous case, let each variable be a unique natural number mapped to that number. Again define a machine that enumerates every statement and assign all sounds in the same way.
					</p>
					<p>
						Define the machine to order-n halt in accordance with the "odd case" definition.
					</p>
					<p>
						If the statement is true, then there exists infinitely many existential variables that will allow the statement to always be satisfied regardless of the other forall statements. This means there exists infinitely many sequences of order-k sound for each order-(k+1) sound that will always be played and the machine will not order-n halt.
						If the statement is false, then there exists only finitely many values of \(a\) for which there are existential variables that can satisfy all lower \(\forall\) quantifiers. This indicates the machine will eventually order-n halt as it will have encountered all finitely many such values.
					</p>
					<p>
						Therefore this machine's order-n halting problem is equivalent to the negation of the \(\Pi_{n+1}\) statement which is a \(\Sigma_{n+1}\) problem.
					</p>
					<p>
						<strong>Remark:</strong> The order-0 and order-1 cases are special because the only cases with only 1 existential quantifier. However, these are both well known to encode any \(\Sigma_1\) and \(\Pi_2\) statement respectively so those cases works too.
					</p>
					<p>
						<strong>QED</strong>
					</p>
				</sub-block>
				<p>
					You may have some questions about this construction. Allow me to explain.
				</p>
				<p>
					<strong>"Why do you break the mapping from number of sounds to number of arithmetical hierarchy jumps?"</strong>
				</p>
				<p>
					This is actually a property that was maintained in the original three constructions! You probably just didn't think about it that way.
					<br><br>
					The order-0 and order-1 halting problems only have the beep state. Though you may not think about the original halting problem having the beep state, it's halting problem is to halt the first time it beeps! It's only when you reach order-3 that you have to add a new sound. This fits with the construction.
				</p>
				<p>
					<strong>"Is it possible to have a construction in terms of numbers like the beeping booping case instead of leaving it defined as an arbitrary equivalence class?"</strong>
				</p>
				<p>
					Sure, here's such a construction. Although I am not prescribing this as the best way to encode the problem. As long as the unique equivalence class behavior is maintained, any construction will work.
				</p>
				<button id="btn_tonemap_proof" class="proof-button"></button>
				<sub-block id="tonemap_proof">
					<p>
						Define the base case order-1 sound to always have a value of 1.
					</p>
					<p>
						Now, to derive the next highest value, take the number that corresponds to the value of each previous lower order sound, and based on the position in the list, and raise it to the power of the next prime number. Then multiply them all together to get the new value for the higher order sound.
					</p>
					<p>
						As an example, for an order 3 construction, if you had "(buzz) 3 5 5 7 (buzz)" the value of the second buzz would be \(2^{3} \cdot 3^{5} \cdot 5^{5} \cdot 7^{7}\)
					</p>
					<p>
						You can continue on, creating larger and larger towers where the height of the exponential tower corresponds to the order of the sound - 1. At all stages, a unique value will be defined based on the order, value, and count of each lower level sound by the fundamental theorem of arithmetic. A nice property is that aside from needing to distinguish between different kinds of "1"s, a value of order n only needs to look at towers of height n - 1.
					</p>
					<p>
						As such, a way to distinguish arbitrarily high order values exists.
					</p>
					<p>
						QED
					</p>
				</sub-block>
				<p>
					<strong>"Why the distinction between the odd and even case?"</strong>
				</p>
				<p>
					Because the arithmetical hierarchy makes that distinction. A \(\Pi_1\) statement corresponds to "\(\forall\)", \(\Pi_2\) corresponds to "\(\forall \exists\)", \(\Pi_3\) corresponds to "\(\forall \exists \forall\)" and so on. The value of the last quantifier depends on the parity of the n in \(\Pi_n\).
					I think it's perfectly natural to think that higher order halting problems should make the distinction.
				</p>
				<p>
					<strong>"Can a state transition have multiple sounds attached to it?"</strong>
				</p>
				<p>
					I think there's a strong case for allowing the overloading of states! However, to make things cleaner I won't be considering overloaded states in this article.
				</p>
				<p>
					If you allow the overloading of states, you'd need to specify the order in which the sounds are played. Perhaps in increasing order of the sound's order.
				</p>
				<p>
					One thing to note is that any behavior you could get with an overloaded state is also possible to achieve without overloading by adding sufficient instructions.
				</p>
				<p>
					Both systems are sufficiently powerful to do anything interesting that the other can do. I'm curious what people think is better. Let me know!
				</p>
				<p>
					<strong>"So why should we use this construction and not some other construction?"</strong>
				</p>
				<p>
					Let's look back at our criterion
				</p>
				<p>
					- It extends the Beeping and Beeping Booping constructions in a natural way. The first one especially is considered by many to almost be a "canonical" way to extend the strength of turing machines. The alternative construction by Racheline also extends the Beeping construction, but requires you to redefine the Beeping Booping construction. Mine allows you to keep that.
					<br><br>
					- Adding a higher order sound does not affect the execution of the turing machine on a lower order. This can be interpreted as any machine's tape history will remain identical no matter what sounds you add, but this is even more general. Any machine with a set of order-n sounds will not have its order-n halting problem be affected by adding a new order-(n+1) without overriding other sounds.
					<br>
					In my opinion, this is a very nice property.
					<br><br>
					- There is a nice correspondence between number of sounds and arithmetical strength. You need exactly \(\lfloor n/2 \rfloor\) sounds to encode any statement of \(n\) strength.
					<br><br>
					- Each jump in strength is trivial. You add one sound on the odd cases and a question associated with that sound. You don't even need to define the notion of an oracle to describe a machine's order-n halting problem.
					<br><br>
					- The extension to all higher order busy beavers is well defined.
					<br><br>
					So, while there are other constructions you can use, this construction has nice properties that many others wont. As mentioned earlier, Racheline's alternative construction also satisfies most of these, but I will discuss that later.
				</p>
				<p>
					<strong>"Can you give an example of a construction of a machine with a higher order (>2) halting problem?"</strong>
				</p>
				<p>
					Here's a trivial example that we can use to examine what higher order halting problems look like. Take the machine with the following transition table:
				</p>
				<table>
					<tr>
						<th>State</th> <th>0</th> <th>1</th>
					</tr>
					<tr>
						<td>A</td> <td>1LB (Boop)</td> <td>1RA (Beep)</td>
					</tr>
					<tr>
						<td>B</td> <td>0RA (Buzz)</td> <td>0LB</td>
					</tr>
				</table>
				<p>
					This really simple machine just counts up in binary on the tape forever. It obviously doesn't halt as it doesn't have a halt state. The order-1 halting problem would be do you always encounter a 1 on the tape moving right, which translates to "does there always exist a binary number with a 1 in the expansion"? To which the answer should obviously be yes, so this machine doesn't order-1 halt.
				</p>
				<p>
					The order-2 halting problem asks if there is some string of consecutive 1s for which there are infinitely many binary numbers that contain that string of 1s. The answer to this is also yes, so this machine order-2 halts at step 1.
				</p>
				<p>
					The order-3 halting problem asks if there are infinitely many starting strings of consecutive 1s that appear infinitely often. Again, because this is binary, the answer is yes so this machine does not order-3 halt.
				</p>
				<p>
					The order-4 halting problem is equivalent to the order-3 halting problem in this case because a boop only ever occurs once between two buzzes. It's asking, when incrementing in binary, is there a sequence of ones and zeros that will always be encountered, which is true, so this machine order-4 halts at step 2.
				</p>
				<p>
					Wait... what?
				</p>
				<h3>
					A machine order-n halting DOES NOT imply that it order-(n+1) halts!
				</h3>
				<hr>
				<p>
					You may be asking something along the lines of "Katelyn, what the hell have you done?" or "did you do something wrong?". Worry not! I can explain!
				</p>
				<p>
					This was a really surprising result to me at first. However, as it turns out, this was <i>already</i> a property of the standard halting problem and the beeping halting problem, you probably just never thought about it like that.
				</p>
				<p>
					You'll often see the halting problem phrased in terms of "undefined transitions". In essence, it is asking if a given state is ever reached. So for a machine to not quasihalt, it needs to reach a state infinitely many times.
					Thus, if you define the halting problem on a state that a machine that doesn't quasihalt on, it necessarily has to halt, otherwise that transition would never be reached in the first place and it trivially quasihalts for that state.
				</p>
				<p>
					So in fact, the order of implication for odd n is that if a machine is order-n nonhalting, then it order-(n-1) halts. And the contrapositive is that if it does not order-(n-1) halt, it order-(n) halts.
					<br><br>
					Quick note in case it's necessary, this doesn't let you solve the halting problem. A machine order-(n-1) halting for odd n does not let you determine if it order-n halts or not.
				</p>
				<h2>
					Higher Order Busy Beavers and Notation
				</h2>
				<hr>
				<p>
					We can define higher order busy beaver functions now, using these higher order halting problems.
					<br><br>
					Let \(\text{BB}_k(n)\) denote the greatest number of steps made by an n-state turing machine with k unique sounds before order-k halting.
					I suspect very few values of these are truly solvable beyond the initial busy beaver domain. You may have more luck with \(\text{BBi}_k(n)\), where in this case
					n denotes the number of instructions.
				</p>
				<h3>
					Properties of Higher Order Busy Beavers
				</h3>
				<p>
					<strong>Theorem 1:</strong> Each \(\text{BB}_{k + 1}(n)\) grows uncomputably faster than \(\text{BB}_{k}(n)\) for all k. This is true because if you had a function that acted as a combination of \(\text{BB}_k(n)\) and any computable function, you could bound \(\text{BB}_{k+1}(n)\) and solve the order-(k+1) halting problem with only an order-k halting oracle, which is impossible.
				</p>
				<p>
					<strong>Theorem 2:</strong> For even n, determining whether a machine has order-(n+1) halted is as hard as solving the order-n halting problem. For odd n, determining whether a machine has order-(n+1) halted is as hard as solving the order-n halting problem.
				</p>
				<button id="btn_halt_diff_proof" class="proof-button"></button>
				<sub-block id="halt_diff_proof">
					<p>
						<strong>Case 1:</strong> Let n = 2k. Assume we have a step for which we suspect a machine has order-(n+1) halted.
					</p>
					<p>
						By definition, to prove that it has order-(n+1) halted you have to prove that all finitely many subsequences of order-k sounds preceeding an order-(k+1) sound that are going to be played infinitely often have been played at least once.
						<br><br>
						If you have a list of all such known infinitely playing sequences, all you need to do is construct a new machine that follows the same rules except it has exceptions not to play an order-(k+1) sound that has any of those subsequences preceeding it. Then you can run an order-n halting oracle to prove whether it will ever find a counterexample. This completes case 1 minus one detail that will be proven at the end.
					</p>
					<p>
						<strong>Case 2:</strong> Let n = 2k + 1. Assume we have a step for which we suspect a machine has order-(n+1) halted.
					</p>
					<p>
						Like last time, we address the definition of order-(n+1) halting. In this case, it halts on the first step that an order-(k+1) sound with a specific preceeding subsequence of order-k sounds occurs that will later occur infinitely often.
					</p>
					<p>
						To show it hasn't halted, we need to show that it will eventually encounter another order-(k+1) sound with a preceeding order-k subsequence. To show this, build a new machine that ends up with the exact same values on the tape, but only plays specific order-k sounds if they will produce our desired order-(k+1). Now we apply our order-k oracle. If the oracle says it doesn't order-k halt, then we know that eventually it will stop playing that order-(k+1) sound eventually. This implies our machine has not yet halted. This partially completes case 2.
					</p>
					<p>
						Quick address for both cases. This sets an upper bound on the difficulty, but a lower bound is trivially derived by the fact that if you could solve these problems with an order-(k-1) oracle, then you could solve the order-k halting problem with an order-(k-1) oracle which is impossible. Doing so will be left as an exercise.
					</p>
					<p>
						QED
					</p>
				</sub-block>
				<p>
					<strong>Remark:</strong> I cannot find a way to prove \(\text{BB}_{k+1}(n) \geq \text{BB}_{k}(n)\) for all k and n. I conjecture this may be because it's actually false in general, and there may be some obscure case where this fails. If you do have a proof (even if it's just for the even or odd case) please send it my way! However, I can prove the following:
				</p>
				<p>
					<strong>Theorem 3: </strong> \(\text{BB}_k(n) \leq \text{BB}_{k+2}(n)\) for all k and n. This is necessarily true, because one can shift up the order of all the sounds by 2 and not include either of the 2 lowest order sounds. This gives an identical halting problem. My definitions don't stipulate that a higher order machine needs all of the lower order sounds, you'll just get a more boring machine.

				</p>
				<h3>
					Extended Standard TM Notation
				</h3>
				<br>
				<p>
					If we want any hope of solving higher order busy beavers, ideally we'd have a way of compactly representing a machine with oracles attached.
				</p>
				<p>
					Fortunately, I propose a relatively simple addition to the standard notation used for representing a TM code. We can add a single number at each state representing the order of the sound it makes.
					<br><br>
					Say we had a machine with the following transition table:
				</p>
				<table>
					<tr>
						<th>State</th> <th>0</th> <th>1</th>
					</tr>
					<tr>
						<td>A</td> <td>1RB (Beep)</td> <td>1LA</td>
					</tr>
					<tr>
						<td>B</td> <td>1LC</td> <td>0RE</td>
					</tr>
					<tr>
						<td>C</td> <td>1LF</td> <td>1LD (Beep)</td>
					</tr>
					<tr>
						<td>D</td> <td>0RB</td> <td>0LA (Buzz)</td>
					</tr>
					<tr>
						<td>E</td> <td>1RC (Boop)</td> <td>1RE</td>
					</tr>
					<tr>
						<td>F</td> <td>HALT / undefined</td> <td>0LD</td>
					</tr>
				</table>
				<p>
					Then we could represent it with the following TM code, where each state is represented with 4 characters now: <br>
				</p>
				<code-block style="font-size: 16pt; max-width: 80%; align-self: center; text-align: center;">
					<code-line>1RB11LA0_<wbr>1LC00RE0_<wbr>1LF01LD1_<wbr>0RB00LA2_<wbr>1RC31RE0_<wbr>----0LD0</code-line>
				</code-block>
				<p>
					(Note: This is just the Space Needle transition table with random sounds added. This exact configuration likely doesn't do anything interesting)
				</p>
				<p>
					This feels like a relatively natural way to extend the existing notation without running into weird conflicts. However, the write symbol of one state and the sound order of the previous can seem to merge which is only saved by the fact that each state is 4 characters wide. If we go beyond 9 symbols, or 9 oracle levels, this notation will run into some trouble.
				</p>
				<p>
					This is why I propose this alternative notation in which you index sound levels with a, b, c, ... (lowercase) with a being the default empty sound.
				</p>
				<code-block style="font-size: 16pt; max-width: 80%; align-self: center; text-align: center;">
					<code-line>1RBb1LAa_<wbr>1LCa0REa_<wbr>1LFa1LDb_<wbr>0RBa0LAc_<wbr>1RCd1REa_<wbr>----0LDa</code-line>
				</code-block>
				<p>
					I personally lean more towards the lowercase letter notation to prevent future confusion, but I would love to hear what people think on this.
				</p>
				<h3>
					Known values of \(\text{BB}_k(n)\)
				</h3>
				<hr>
				<table>
					<tr>
						<th>Domain</th> <th>n=1</th> <th>n=2</th> <th>n=3</th> <th>n=4</th>
					</tr>
					<tr>
						<td>\(\text{BB}_0\)</td> <td>1</td> <td>6</td> <td>21</td> <td>107</td>
					</tr>
					<tr>
						<td>\(\text{BB}_1\)</td> <td>1</td> <td>6</td> <td>55</td> <td>\(\geq 32,779,478\)</td>
					</tr>
					<tr>
						<td>\(\text{BB}_2\)</td> <td>2</td> <td>17</td> <td>???</td> <td>???</td>
					</tr>
					<tr>
						<td>\(\text{BB}_3\)</td> <td>2</td> <td>\(\geq 18\)</td> <td>???</td> <td>???</td>
					</tr>
				</table>
				<p>
					As mentioned earlier, very few values of higher order busy beavers are known! While these problems get incredibly hard very quickly, I would hope that \(\text{BB}_1(4), \text{BB}_2(3), \text{BB}_3(2), \text{BB}_4(2)\) can all be solved.
				</p>
				<p>
					The current value for \(\text{BB}_2(2)\) comes from <tm-code>1RB01LA0_0LA11RA2</tm-code> / <tm-code>1RBa1LAa_0LAb1RAc</tm-code> as proven by discord user racheline
				</p>
				<p>
					The current bound for \(\text{BB}_3(2)\) comes from <tm-code>1RBb0LBd_1LAc1RAa</tm-code>
				</p>
				<p>
					I think the possibility that you encounter cryptids by \(\text{BB}_2(4)\) or \(\text{BB}_3(3)\) is real.
				</p>
				<p>
					Extending this to solve multi-symbol machines would also be a worthwhile endeavor! As far as I know, research into higher order multi-symbol machines is basically nonexistent as of this moment.
				</p>
				<h2>
					The Single-Beep Construction
				</h2>
				<hr>
				<p>
					As I was fleshing out this definition, discord user Racheline introduced to me an alternative way of defining higher order halting problems that requires no additional sounds be added to a turing machine beyond the original beep state, while retaining many of the desirable properties we're after. I'll call this the single-beep construction and my construction the multi-beep construction.
				</p>
				<p>
					It works by defining an "n-beep" to be n consecutive beeps in a row. Then for each higher level, you can look at sequences of (n-1)-beeps between n-beeps. This has all the same properties as the multi-beep construction, because an n-beep is functionally identical to a higher order beep in the multi-beep construction.
				</p>
				<p>
					This construction has some advantages, mainly it's in some sense mathematically "simpler". You don't need to define any higher order sounds at all and a machine's higher-order behavior isn't limited by the number of instructions a machine has. As well, for a given set of instructions, the search space for the single-beep construction is smaller meaning it's easier to prove more values of the corresponding higher order busy beavers.
				</p>
				<p>
					I personally, however, prefer the multi-beep construction and that is what I will most likely be using. My justification is that the multi-beep construction contains the definition of the beeping booping construction, so that doesn't have to be thrown out. As well, it makes the execution for a TM cleaner, and I believe you're likely to find more interesting behavior early on with the multi-beep construction even if both constructions have the same power in the limit.
				</p>
				<p>
					The single-beep construction is also more restrictive in that you have to beep consecutively some number of times. You could create a different construction that avoids this, but then you get into the problem that whether a given beep is an n-beep becomes undecidable which is in my opinion an undesirable property.
				</p>
				<p>
					However, this is a very cool construction! I find it fascinating only a single beep is enough to go all the way to arbitrarily complex arithmetical statements, and this specific construction is probably worth investigating on its own.
				</p>
				<h2>
					A Quick Note for the Googologists
				</h2>
				<hr>
				<p>
					Using the multi-beep construction, we've defined all \(\text{BB}_k(n)\) for all natural k and n. But now, some may get the temptation to start climbing highter.
					<br><br>
					Define the diagonalized \(\text{BB}_{\omega}(n) = \text{BB}_n(n)\). This is a monstrously fast growing function, that has to eventually outgrow all uncomputably faster growing \(\text{BB}_k(n)\) functions with only finite k.
				</p>
				<p>
					Some of you may be thinking about the fast growing hierarchy seeing that, and it does feel very similar! However, I haven't found a way to generalize this notion to higher and higher ordinals while keeping in spirit with what the \(k\) represents. I'm leaving that as an exercise to the reader :)
				</p>
				<p>
					Scott Aaronson noted in his blog post <a href="https://www.scottaaronson.com/writings/bignumbers.html">Who Can Name the Bigger Number?</a> the following:
				</p>
				<sub-block>
					"You might think that now, in the biggest-number contest, you could obliterate even an opponent who uses the Busy Beaver sequence by writing something like this:

					\[BB_2(11111)\]
					The problem is that I've never seen these "higher-level Busy Beavers" defined anywhere, probably because, to people who know computability theory, they're a fairly obvious extension of the ordinary Busy Beaver numbers. So our reasonable modern mathematician wouldn't know what number you were naming."
				</sub-block>
				<p>
					In keeping with this statement, I'll now define a number \(D = \text{BB}_{\omega}(10^{100})\). This is a very big number. A big dam number, if you will! It is however certainly smaller than the likes of Rayo's number
				</p>
				<h2>
					Special Thanks
				</h2>
				<hr>
				<p>
					Wanted to write here to say thank you to Racheline for helping me more rigorously define my construction, as well as defining the single-beep construction. I also want to thank John Tromp for his extensive and helpful feedback on the earlier draft of this article.
				</p>
			</main>
		</article>
	</div>
</body>
<script>
	function toggle_element(show_element, button_id, proof_id) {
		button = document.getElementById(button_id);
		if (show_element) {
			document.getElementById(proof_id).style.display = "";
			button.textContent = "[Click to hide proof]"
			button.style.marginBottom = "0px";
		} else {
			document.getElementById(proof_id).style.display = "none";
			button.textContent = "[Click to show proof]"
			button.style.marginBottom = "12px";
		}
	}
	
	halt_diff_pressed = false;
	document.getElementById('btn_halt_diff_proof').addEventListener('click', function() {
		halt_diff_pressed = !halt_diff_pressed;
		toggle_element(halt_diff_pressed, 'btn_halt_diff_proof', 'halt_diff_proof');
	});

	toggle_element(halt_diff_pressed, 'btn_halt_diff_proof', 'halt_diff_proof');


	turing_jump_pressed = false;

	document.getElementById('btn_turing_jmp_proof').addEventListener('click', function() {
		turing_jump_pressed = !turing_jump_pressed;
		toggle_element(turing_jump_pressed, 'btn_turing_jmp_proof', 'turing_jmp_proof');
	});

	toggle_element(turing_jump_pressed, 'btn_turing_jmp_proof', 'turing_jmp_proof');

	tonemap_pressed = false;

	document.getElementById('btn_tonemap_proof').addEventListener('click', function() {
		tonemap_pressed = !tonemap_pressed;
		toggle_element(tonemap_pressed, 'btn_tonemap_proof', 'tonemap_proof');
	});

	toggle_element(tonemap_pressed, 'btn_tonemap_proof', 'tonemap_proof');
</script>